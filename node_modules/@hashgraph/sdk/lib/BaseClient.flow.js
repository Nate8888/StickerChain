/**
 * Flowtype definitions for BaseClient
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.10.0
 */

import {
          grpc
        } from '@improbable-eng/grpc-web';
import {
          ProtobufMessage
        } from '@improbable-eng/grpc-web/dist/typings/message';
import {
          Hbar
        } from './Hbar';
declare var UnaryMethodDefinition: typeof grpc.UnaryMethodDefinition;import {
          Ed25519PrivateKey
        } from './crypto/Ed25519PrivateKey';
import {
          Ed25519PublicKey
        } from './crypto/Ed25519PublicKey';
import {
          AccountId,AccountIdLike
        } from './account/AccountId';
export type TransactionSigner = (msg: Uint8Array) => Uint8Array | Promise<Uint8Array>;
/**
 * If `privateKey` is a string it will be parsed as an `Ed25519PrivateKey`
 */
export interface PrivateKey {
privateKey: Ed25519PrivateKey | string,
} export interface PubKeyAndSigner {
publicKey: Ed25519PublicKey,
signer: TransactionSigner,
} export type SigningOpts = PrivateKey | PubKeyAndSigner;export type Operator = {
account: AccountIdLike,...
} & SigningOpts;export type Nodes = {
[url: string]: AccountIdLike,...
} | Node[];
/**
 * A URL,AccountID pair identifying a Node
 */
export interface Node {
url: string,
id: AccountId,
} export interface ClientConfig {
network?: Nodes,
operator?: Operator,
} declare export class BaseClient  {
_nodes: Node[];
_maxTransactionFee: Hbar;
_maxQueryPayment: Hbar;
constructor(network: Nodes, operator?: Operator): this;
putNode(id: AccountIdLike, url: string): this;

/**
 * Set the operator for the client object
 */
setOperator(account: AccountIdLike, privateKey: Ed25519PrivateKey | string): this;
setOperatorWith(
account: AccountIdLike,
publicKey: Ed25519PublicKey,
signer: TransactionSigner): this;
replaceNodes(network: Nodes): this;
_getOperatorAccountId(): AccountId | void;
_getOperatorSigner(): TransactionSigner | void;
_getOperatorKey(): Ed25519PublicKey | void;

/**
 * Get the current maximum transaction fee.
 */
/* NO PRINT IMPLEMENTED: GetAccessor */ any;

/**
 * Get the current maximum query payment.
 */
/* NO PRINT IMPLEMENTED: GetAccessor */ any;

/**
 * Set the default maximum fee for a transaction.
 * 
 * This can be overridden for an individual transaction with
 * `TransactionBuilder.setMaxTransactionFee()`.
 * 
 * If a transaction's fee will exceed this value, a `HederaStatusError` will be thrown with
 * `ResponseCode.INSUFFICIENT_TX_FEE`.
 * @param maxFee
 */
setMaxTransactionFee(maxFee: Hbar): this;

/**
 * Set the max payment that can be automatically attached to a query.
 * 
 * If this is not called then by default no payments will be made automatically for queries.
 * 
 * If a query will cost more than this amount, a `MaxQueryPaymentExceededError` will be thrown
 * from `QueryBuilder.execute()`.
 * 
 * This can be overridden for an individual query with
 * `query.setPaymentDefault(await query.requestCost())`.
 * @param maxPayment the maximum automatic payment for a query
 */
setMaxQueryPayment(maxPayment: Hbar): this;

/**
 * Get the current account balance.
 * @deprecated `Client.getAccountBalance()` is deprecated with no replacement. Use the `AccountBalanceQuery` directly instead.
 */
getAccountBalance(id: AccountIdLike): Promise<Hbar>;
ping(id: AccountIdLike): Promise<void>;
_randomNode(): Node;
_getNode(node: string | AccountId): Node;
_unaryCall<Rq: ProtobufMessage, Rs: ProtobufMessage>(
url: string,
request: Rq,
method: UnaryMethodDefinition<Rq, Rs>): Promise<Rs>;
}