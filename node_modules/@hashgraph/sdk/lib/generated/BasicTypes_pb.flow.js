/**
 * Flowtype definitions for BasicTypes_pb
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.10.0
 */

import * as jspb from "google-protobuf";
import * as Timestamp_pb from "./Timestamp_pb";
declare export class ShardID mixins jspb.Message {
  getShardnum(): number;
  setShardnum(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ShardID$AsObject;
  static toObject(includeInstance: boolean, msg: ShardID): ShardID$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ShardID,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ShardID;
  static deserializeBinaryFromReader(
    message: ShardID,
    reader: jspb.BinaryReader
  ): ShardID;
}
export type ShardID$AsObject = {
  shardnum: number,
  ...
};
declare export class RealmID mixins jspb.Message {
  getShardnum(): number;
  setShardnum(value: number): void;
  getRealmnum(): number;
  setRealmnum(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RealmID$AsObject;
  static toObject(includeInstance: boolean, msg: RealmID): RealmID$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: RealmID,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): RealmID;
  static deserializeBinaryFromReader(
    message: RealmID,
    reader: jspb.BinaryReader
  ): RealmID;
}
export type RealmID$AsObject = {
  shardnum: number,
  realmnum: number,
  ...
};
declare export class AccountID mixins jspb.Message {
  getShardnum(): number;
  setShardnum(value: number): void;
  getRealmnum(): number;
  setRealmnum(value: number): void;
  getAccountnum(): number;
  setAccountnum(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AccountID$AsObject;
  static toObject(includeInstance: boolean, msg: AccountID): AccountID$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: AccountID,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): AccountID;
  static deserializeBinaryFromReader(
    message: AccountID,
    reader: jspb.BinaryReader
  ): AccountID;
}
export type AccountID$AsObject = {
  shardnum: number,
  realmnum: number,
  accountnum: number,
  ...
};
declare export class FileID mixins jspb.Message {
  getShardnum(): number;
  setShardnum(value: number): void;
  getRealmnum(): number;
  setRealmnum(value: number): void;
  getFilenum(): number;
  setFilenum(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FileID$AsObject;
  static toObject(includeInstance: boolean, msg: FileID): FileID$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: FileID,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): FileID;
  static deserializeBinaryFromReader(
    message: FileID,
    reader: jspb.BinaryReader
  ): FileID;
}
export type FileID$AsObject = {
  shardnum: number,
  realmnum: number,
  filenum: number,
  ...
};
declare export class ContractID mixins jspb.Message {
  getShardnum(): number;
  setShardnum(value: number): void;
  getRealmnum(): number;
  setRealmnum(value: number): void;
  getContractnum(): number;
  setContractnum(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ContractID$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ContractID
  ): ContractID$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ContractID,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ContractID;
  static deserializeBinaryFromReader(
    message: ContractID,
    reader: jspb.BinaryReader
  ): ContractID;
}
export type ContractID$AsObject = {
  shardnum: number,
  realmnum: number,
  contractnum: number,
  ...
};
declare export class TransactionID mixins jspb.Message {
  hasTransactionvalidstart(): boolean;
  clearTransactionvalidstart(): void;
  getTransactionvalidstart(): Timestamp_pb.Timestamp | void;
  setTransactionvalidstart(value?: Timestamp_pb.Timestamp): void;
  hasAccountid(): boolean;
  clearAccountid(): void;
  getAccountid(): AccountID | void;
  setAccountid(value?: AccountID): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TransactionID$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: TransactionID
  ): TransactionID$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: TransactionID,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): TransactionID;
  static deserializeBinaryFromReader(
    message: TransactionID,
    reader: jspb.BinaryReader
  ): TransactionID;
}
export type TransactionID$AsObject = {
  transactionvalidstart?: Timestamp_pb.Timestamp.AsObject,
  accountid?: AccountID$AsObject,
  ...
};
declare export class TopicID mixins jspb.Message {
  getShardnum(): number;
  setShardnum(value: number): void;
  getRealmnum(): number;
  setRealmnum(value: number): void;
  getTopicnum(): number;
  setTopicnum(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TopicID$AsObject;
  static toObject(includeInstance: boolean, msg: TopicID): TopicID$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: TopicID,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): TopicID;
  static deserializeBinaryFromReader(
    message: TopicID,
    reader: jspb.BinaryReader
  ): TopicID;
}
export type TopicID$AsObject = {
  shardnum: number,
  realmnum: number,
  topicnum: number,
  ...
};
declare export class Key mixins jspb.Message {
  hasContractid(): boolean;
  clearContractid(): void;
  getContractid(): ContractID | void;
  setContractid(value?: ContractID): void;
  hasEd25519(): boolean;
  clearEd25519(): void;
  getEd25519(): Uint8Array | string;
  getEd25519_asU8(): Uint8Array;
  getEd25519_asB64(): string;
  setEd25519(value: Uint8Array | string): void;
  hasRsa3072(): boolean;
  clearRsa3072(): void;
  getRsa3072(): Uint8Array | string;
  getRsa3072_asU8(): Uint8Array;
  getRsa3072_asB64(): string;
  setRsa3072(value: Uint8Array | string): void;
  hasEcdsa384(): boolean;
  clearEcdsa384(): void;
  getEcdsa384(): Uint8Array | string;
  getEcdsa384_asU8(): Uint8Array;
  getEcdsa384_asB64(): string;
  setEcdsa384(value: Uint8Array | string): void;
  hasThresholdkey(): boolean;
  clearThresholdkey(): void;
  getThresholdkey(): ThresholdKey | void;
  setThresholdkey(value?: ThresholdKey): void;
  hasKeylist(): boolean;
  clearKeylist(): void;
  getKeylist(): KeyList | void;
  setKeylist(value?: KeyList): void;
  getKeyCase(): $Values<typeof Key$KeyCase>;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Key$AsObject;
  static toObject(includeInstance: boolean, msg: Key): Key$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(message: Key, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Key;
  static deserializeBinaryFromReader(
    message: Key,
    reader: jspb.BinaryReader
  ): Key;
}
declare var Key: typeof npm$namespace$Key;

declare var npm$namespace$Key: {|
  KeyCase: typeof Key$KeyCase
|};
export type Key$AsObject = {
  contractid?: ContractID$AsObject,
  ed25519: Uint8Array | string,
  rsa3072: Uint8Array | string,
  ecdsa384: Uint8Array | string,
  thresholdkey?: ThresholdKey$AsObject,
  keylist?: KeyList$AsObject,
  ...
};

declare export var Key$KeyCase: {|
  +KEY_NOT_SET: 0, // 0
  +CONTRACTID: 1, // 1
  +ED25519: 2, // 2
  +RSA_3072: 3, // 3
  +ECDSA_384: 4, // 4
  +THRESHOLDKEY: 5, // 5
  +KEYLIST: 6 // 6
|};
declare export class ThresholdKey mixins jspb.Message {
  getThreshold(): number;
  setThreshold(value: number): void;
  hasKeys(): boolean;
  clearKeys(): void;
  getKeys(): KeyList | void;
  setKeys(value?: KeyList): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ThresholdKey$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ThresholdKey
  ): ThresholdKey$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ThresholdKey,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ThresholdKey;
  static deserializeBinaryFromReader(
    message: ThresholdKey,
    reader: jspb.BinaryReader
  ): ThresholdKey;
}
export type ThresholdKey$AsObject = {
  threshold: number,
  keys?: KeyList$AsObject,
  ...
};
declare export class KeyList mixins jspb.Message {
  clearKeysList(): void;
  getKeysList(): Array<Key>;
  setKeysList(value: Array<Key>): void;
  addKeys(value?: Key, index?: number): Key;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KeyList$AsObject;
  static toObject(includeInstance: boolean, msg: KeyList): KeyList$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: KeyList,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): KeyList;
  static deserializeBinaryFromReader(
    message: KeyList,
    reader: jspb.BinaryReader
  ): KeyList;
}
export type KeyList$AsObject = {
  keysList: Array<Key$AsObject>,
  ...
};
declare export class Signature mixins jspb.Message {
  hasContract(): boolean;
  clearContract(): void;
  getContract(): Uint8Array | string;
  getContract_asU8(): Uint8Array;
  getContract_asB64(): string;
  setContract(value: Uint8Array | string): void;
  hasEd25519(): boolean;
  clearEd25519(): void;
  getEd25519(): Uint8Array | string;
  getEd25519_asU8(): Uint8Array;
  getEd25519_asB64(): string;
  setEd25519(value: Uint8Array | string): void;
  hasRsa3072(): boolean;
  clearRsa3072(): void;
  getRsa3072(): Uint8Array | string;
  getRsa3072_asU8(): Uint8Array;
  getRsa3072_asB64(): string;
  setRsa3072(value: Uint8Array | string): void;
  hasEcdsa384(): boolean;
  clearEcdsa384(): void;
  getEcdsa384(): Uint8Array | string;
  getEcdsa384_asU8(): Uint8Array;
  getEcdsa384_asB64(): string;
  setEcdsa384(value: Uint8Array | string): void;
  hasThresholdsignature(): boolean;
  clearThresholdsignature(): void;
  getThresholdsignature(): ThresholdSignature | void;
  setThresholdsignature(value?: ThresholdSignature): void;
  hasSignaturelist(): boolean;
  clearSignaturelist(): void;
  getSignaturelist(): SignatureList | void;
  setSignaturelist(value?: SignatureList): void;
  getSignatureCase(): $Values<typeof Signature$SignatureCase>;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Signature$AsObject;
  static toObject(includeInstance: boolean, msg: Signature): Signature$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: Signature,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): Signature;
  static deserializeBinaryFromReader(
    message: Signature,
    reader: jspb.BinaryReader
  ): Signature;
}
declare var Signature: typeof npm$namespace$Signature;

declare var npm$namespace$Signature: {|
  SignatureCase: typeof Signature$SignatureCase
|};
export type Signature$AsObject = {
  contract: Uint8Array | string,
  ed25519: Uint8Array | string,
  rsa3072: Uint8Array | string,
  ecdsa384: Uint8Array | string,
  thresholdsignature?: ThresholdSignature$AsObject,
  signaturelist?: SignatureList$AsObject,
  ...
};

declare export var Signature$SignatureCase: {|
  +SIGNATURE_NOT_SET: 0, // 0
  +CONTRACT: 1, // 1
  +ED25519: 2, // 2
  +RSA_3072: 3, // 3
  +ECDSA_384: 4, // 4
  +THRESHOLDSIGNATURE: 5, // 5
  +SIGNATURELIST: 6 // 6
|};
declare export class ThresholdSignature mixins jspb.Message {
  hasSigs(): boolean;
  clearSigs(): void;
  getSigs(): SignatureList | void;
  setSigs(value?: SignatureList): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ThresholdSignature$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: ThresholdSignature
  ): ThresholdSignature$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: ThresholdSignature,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): ThresholdSignature;
  static deserializeBinaryFromReader(
    message: ThresholdSignature,
    reader: jspb.BinaryReader
  ): ThresholdSignature;
}
export type ThresholdSignature$AsObject = {
  sigs?: SignatureList$AsObject,
  ...
};
declare export class SignatureList mixins jspb.Message {
  clearSigsList(): void;
  getSigsList(): Array<Signature>;
  setSigsList(value: Array<Signature>): void;
  addSigs(value?: Signature, index?: number): Signature;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SignatureList$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: SignatureList
  ): SignatureList$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: SignatureList,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): SignatureList;
  static deserializeBinaryFromReader(
    message: SignatureList,
    reader: jspb.BinaryReader
  ): SignatureList;
}
export type SignatureList$AsObject = {
  sigsList: Array<Signature$AsObject>,
  ...
};
declare export class SignaturePair mixins jspb.Message {
  getPubkeyprefix(): Uint8Array | string;
  getPubkeyprefix_asU8(): Uint8Array;
  getPubkeyprefix_asB64(): string;
  setPubkeyprefix(value: Uint8Array | string): void;
  hasContract(): boolean;
  clearContract(): void;
  getContract(): Uint8Array | string;
  getContract_asU8(): Uint8Array;
  getContract_asB64(): string;
  setContract(value: Uint8Array | string): void;
  hasEd25519(): boolean;
  clearEd25519(): void;
  getEd25519(): Uint8Array | string;
  getEd25519_asU8(): Uint8Array;
  getEd25519_asB64(): string;
  setEd25519(value: Uint8Array | string): void;
  hasRsa3072(): boolean;
  clearRsa3072(): void;
  getRsa3072(): Uint8Array | string;
  getRsa3072_asU8(): Uint8Array;
  getRsa3072_asB64(): string;
  setRsa3072(value: Uint8Array | string): void;
  hasEcdsa384(): boolean;
  clearEcdsa384(): void;
  getEcdsa384(): Uint8Array | string;
  getEcdsa384_asU8(): Uint8Array;
  getEcdsa384_asB64(): string;
  setEcdsa384(value: Uint8Array | string): void;
  getSignatureCase(): $Values<typeof SignaturePair$SignatureCase>;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SignaturePair$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: SignaturePair
  ): SignaturePair$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: SignaturePair,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): SignaturePair;
  static deserializeBinaryFromReader(
    message: SignaturePair,
    reader: jspb.BinaryReader
  ): SignaturePair;
}
declare var SignaturePair: typeof npm$namespace$SignaturePair;

declare var npm$namespace$SignaturePair: {|
  SignatureCase: typeof SignaturePair$SignatureCase
|};
export type SignaturePair$AsObject = {
  pubkeyprefix: Uint8Array | string,
  contract: Uint8Array | string,
  ed25519: Uint8Array | string,
  rsa3072: Uint8Array | string,
  ecdsa384: Uint8Array | string,
  ...
};

declare export var SignaturePair$SignatureCase: {|
  +SIGNATURE_NOT_SET: 0, // 0
  +CONTRACT: 2, // 2
  +ED25519: 3, // 3
  +RSA_3072: 4, // 4
  +ECDSA_384: 5 // 5
|};
declare export class SignatureMap mixins jspb.Message {
  clearSigpairList(): void;
  getSigpairList(): Array<SignaturePair>;
  setSigpairList(value: Array<SignaturePair>): void;
  addSigpair(value?: SignaturePair, index?: number): SignaturePair;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SignatureMap$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: SignatureMap
  ): SignatureMap$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: SignatureMap,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): SignatureMap;
  static deserializeBinaryFromReader(
    message: SignatureMap,
    reader: jspb.BinaryReader
  ): SignatureMap;
}
export type SignatureMap$AsObject = {
  sigpairList: Array<SignaturePair$AsObject>,
  ...
};
declare export class FeeComponents mixins jspb.Message {
  getMin(): number;
  setMin(value: number): void;
  getMax(): number;
  setMax(value: number): void;
  getConstant(): number;
  setConstant(value: number): void;
  getBpt(): number;
  setBpt(value: number): void;
  getVpt(): number;
  setVpt(value: number): void;
  getRbh(): number;
  setRbh(value: number): void;
  getSbh(): number;
  setSbh(value: number): void;
  getGas(): number;
  setGas(value: number): void;
  getTv(): number;
  setTv(value: number): void;
  getBpr(): number;
  setBpr(value: number): void;
  getSbpr(): number;
  setSbpr(value: number): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeeComponents$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: FeeComponents
  ): FeeComponents$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: FeeComponents,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): FeeComponents;
  static deserializeBinaryFromReader(
    message: FeeComponents,
    reader: jspb.BinaryReader
  ): FeeComponents;
}
export type FeeComponents$AsObject = {
  min: number,
  max: number,
  constant: number,
  bpt: number,
  vpt: number,
  rbh: number,
  sbh: number,
  gas: number,
  tv: number,
  bpr: number,
  sbpr: number,
  ...
};
declare export class TransactionFeeSchedule mixins jspb.Message {
  getHederafunctionality(): $ElementType<
    HederaFunctionalityMap,
    $Keys<HederaFunctionalityMap>
  >;
  setHederafunctionality(
    value: $ElementType<HederaFunctionalityMap, $Keys<HederaFunctionalityMap>>
  ): void;
  hasFeedata(): boolean;
  clearFeedata(): void;
  getFeedata(): FeeData | void;
  setFeedata(value?: FeeData): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TransactionFeeSchedule$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: TransactionFeeSchedule
  ): TransactionFeeSchedule$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: TransactionFeeSchedule,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): TransactionFeeSchedule;
  static deserializeBinaryFromReader(
    message: TransactionFeeSchedule,
    reader: jspb.BinaryReader
  ): TransactionFeeSchedule;
}
export type TransactionFeeSchedule$AsObject = {
  hederafunctionality: $ElementType<
    HederaFunctionalityMap,
    $Keys<HederaFunctionalityMap>
  >,
  feedata?: FeeData$AsObject,
  ...
};
declare export class FeeData mixins jspb.Message {
  hasNodedata(): boolean;
  clearNodedata(): void;
  getNodedata(): FeeComponents | void;
  setNodedata(value?: FeeComponents): void;
  hasNetworkdata(): boolean;
  clearNetworkdata(): void;
  getNetworkdata(): FeeComponents | void;
  setNetworkdata(value?: FeeComponents): void;
  hasServicedata(): boolean;
  clearServicedata(): void;
  getServicedata(): FeeComponents | void;
  setServicedata(value?: FeeComponents): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeeData$AsObject;
  static toObject(includeInstance: boolean, msg: FeeData): FeeData$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: FeeData,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): FeeData;
  static deserializeBinaryFromReader(
    message: FeeData,
    reader: jspb.BinaryReader
  ): FeeData;
}
export type FeeData$AsObject = {
  nodedata?: FeeComponents$AsObject,
  networkdata?: FeeComponents$AsObject,
  servicedata?: FeeComponents$AsObject,
  ...
};
declare export class FeeSchedule mixins jspb.Message {
  clearTransactionfeescheduleList(): void;
  getTransactionfeescheduleList(): Array<TransactionFeeSchedule>;
  setTransactionfeescheduleList(value: Array<TransactionFeeSchedule>): void;
  addTransactionfeeschedule(
    value?: TransactionFeeSchedule,
    index?: number
  ): TransactionFeeSchedule;
  hasExpirytime(): boolean;
  clearExpirytime(): void;
  getExpirytime(): Timestamp_pb.TimestampSeconds | void;
  setExpirytime(value?: Timestamp_pb.TimestampSeconds): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeeSchedule$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: FeeSchedule
  ): FeeSchedule$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: FeeSchedule,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): FeeSchedule;
  static deserializeBinaryFromReader(
    message: FeeSchedule,
    reader: jspb.BinaryReader
  ): FeeSchedule;
}
export type FeeSchedule$AsObject = {
  transactionfeescheduleList: Array<TransactionFeeSchedule$AsObject>,
  expirytime?: Timestamp_pb.TimestampSeconds.AsObject,
  ...
};
declare export class CurrentAndNextFeeSchedule mixins jspb.Message {
  hasCurrentfeeschedule(): boolean;
  clearCurrentfeeschedule(): void;
  getCurrentfeeschedule(): FeeSchedule | void;
  setCurrentfeeschedule(value?: FeeSchedule): void;
  hasNextfeeschedule(): boolean;
  clearNextfeeschedule(): void;
  getNextfeeschedule(): FeeSchedule | void;
  setNextfeeschedule(value?: FeeSchedule): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CurrentAndNextFeeSchedule$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: CurrentAndNextFeeSchedule
  ): CurrentAndNextFeeSchedule$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: CurrentAndNextFeeSchedule,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): CurrentAndNextFeeSchedule;
  static deserializeBinaryFromReader(
    message: CurrentAndNextFeeSchedule,
    reader: jspb.BinaryReader
  ): CurrentAndNextFeeSchedule;
}
export type CurrentAndNextFeeSchedule$AsObject = {
  currentfeeschedule?: FeeSchedule$AsObject,
  nextfeeschedule?: FeeSchedule$AsObject,
  ...
};
declare export class NodeAddress mixins jspb.Message {
  getIpaddress(): Uint8Array | string;
  getIpaddress_asU8(): Uint8Array;
  getIpaddress_asB64(): string;
  setIpaddress(value: Uint8Array | string): void;
  getPortno(): number;
  setPortno(value: number): void;
  getMemo(): Uint8Array | string;
  getMemo_asU8(): Uint8Array;
  getMemo_asB64(): string;
  setMemo(value: Uint8Array | string): void;
  getRsaPubkey(): string;
  setRsaPubkey(value: string): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NodeAddress$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: NodeAddress
  ): NodeAddress$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: NodeAddress,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): NodeAddress;
  static deserializeBinaryFromReader(
    message: NodeAddress,
    reader: jspb.BinaryReader
  ): NodeAddress;
}
export type NodeAddress$AsObject = {
  ipaddress: Uint8Array | string,
  portno: number,
  memo: Uint8Array | string,
  rsaPubkey: string,
  ...
};
declare export class NodeAddressBook mixins jspb.Message {
  clearNodeaddressList(): void;
  getNodeaddressList(): Array<NodeAddress>;
  setNodeaddressList(value: Array<NodeAddress>): void;
  addNodeaddress(value?: NodeAddress, index?: number): NodeAddress;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NodeAddressBook$AsObject;
  static toObject(
    includeInstance: boolean,
    msg: NodeAddressBook
  ): NodeAddressBook$AsObject;
  static extensions: {
    [key: number]: jspb.ExtensionFieldInfo<jspb.Message>,
    ...
  };
  static extensionsBinary: {
    [key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>,
    ...
  };
  static serializeBinaryToWriter(
    message: NodeAddressBook,
    writer: jspb.BinaryWriter
  ): void;
  static deserializeBinary(bytes: Uint8Array): NodeAddressBook;
  static deserializeBinaryFromReader(
    message: NodeAddressBook,
    reader: jspb.BinaryReader
  ): NodeAddressBook;
}
export type NodeAddressBook$AsObject = {
  nodeaddressList: Array<NodeAddress$AsObject>,
  ...
};
export interface HederaFunctionalityMap {
  NONE: 0;
  CRYPTOTRANSFER: 1;
  CRYPTOUPDATE: 2;
  CRYPTODELETE: 3;
  CRYPTOADDCLAIM: 4;
  CRYPTODELETECLAIM: 5;
  CONTRACTCALL: 6;
  CONTRACTCREATE: 7;
  CONTRACTUPDATE: 8;
  FILECREATE: 9;
  FILEAPPEND: 10;
  FILEUPDATE: 11;
  FILEDELETE: 12;
  CRYPTOGETACCOUNTBALANCE: 13;
  CRYPTOGETACCOUNTRECORDS: 14;
  CRYPTOGETINFO: 15;
  CONTRACTCALLLOCAL: 16;
  CONTRACTGETINFO: 17;
  CONTRACTGETBYTECODE: 18;
  GETBYSOLIDITYID: 19;
  GETBYKEY: 20;
  CRYPTOGETCLAIM: 21;
  CRYPTOGETSTAKERS: 22;
  FILEGETCONTENTS: 23;
  FILEGETINFO: 24;
  TRANSACTIONGETRECORD: 25;
  CONTRACTGETRECORDS: 26;
  CRYPTOCREATE: 27;
  SYSTEMDELETE: 28;
  SYSTEMUNDELETE: 29;
  CONTRACTDELETE: 30;
  FREEZE: 31;
  CREATETRANSACTIONRECORD: 32;
  CRYPTOACCOUNTAUTORENEW: 33;
  CONTRACTAUTORENEW: 34;
  GETVERSION: 35;
  TRANSACTIONGETRECEIPT: 36;
  CONSENSUSCREATETOPIC: 50;
  CONSENSUSUPDATETOPIC: 51;
  CONSENSUSDELETETOPIC: 52;
  CONSENSUSGETTOPICINFO: 53;
  CONSENSUSSUBMITMESSAGE: 54;
}
declare export var HederaFunctionality: HederaFunctionalityMap;
